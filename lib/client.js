// Generated by CoffeeScript 2.0.0-alpha1
(function() {
  var $host, $onFailure, core;

  $host = null;

  $onFailure = null;

  core = {};

  core.host = function(host) {
    if (host[host.length - 1] !== '/') {
      host += '/';
    }
    return $host = host;
  };

  core.onFailure = function(onFailure) {
    return $onFailure = onFailure;
  };

  core.splitData = function(data) {
    var cursor, dateDict, fileDict, jsonDict, traversal;
    jsonDict = {};
    dateDict = {};
    fileDict = {};
    cursor = [];
    traversal = function(node) {
      var name, type;
      type = typeof node;
      if (type === 'boolean' || type === 'number' || type === 'string') {
        jsonDict[cursor.join('.')] = node;
      } else if (node instanceof Date) {
        dateDict[cursor.join('.')] = node;
      } else if (node instanceof File) {
        fileDict[cursor.join('.')] = node;
      } else {
        for (name in node) {
          cursor.push(name);
          traversal(node[name]);
        }
      }
      return cursor.pop();
    };
    traversal(data);
    return {
      jsonDict: jsonDict,
      dateDict: dateDict,
      fileDict: fileDict
    };
  };

  core.createFormData = function(data) {
    var formData;
    formData = new FormData();
    data = core.splitData(data);
    core.appendJSON(formData, data.jsonDict);
    core.appendDate(formData, data.dateDict);
    core.appendFile(formData, data.fileDict);
    return formData;
  };

  core.appendJSON = function(formData, jsonDict) {
    return formData.append('$jsonDict', JSON.stringify(jsonDict));
  };

  core.appendDate = function(formData, dateDict) {
    var key;
    for (key in dateDict) {
      dateDict[key] = dateDict[key].getTime();
    }
    return formData.append('$dateDict', JSON.stringify(dateDict));
  };

  core.appendFile = function(formData, fileDict) {
    var key, results;
    results = [];
    for (key in fileDict) {
      results.push(formData.append(key, fileDict[key]));
    }
    return results;
  };

  core.setHeader = function(xhr, ioName) {
    var token;
    xhr.setRequestHeader('rubic-io', ioName);
    token = localStorage.getItem('rubic-token');
    if (token) {
      return xhr.setRequestHeader('rubic-token', token);
    }
  };

  core.call = function(ioName, data = {}) {
    var formData, xhr;
    if (typeof ioName !== 'string') {
      throw "io's name should be a string";
    }
    formData = core.createFormData(data);
    xhr = new XMLHttpRequest();
    xhr.open('POST', $host, true);
    core.setHeader(xhr, ioName);
    xhr.send(formData);
    return new Promise(function(resolve, reject) {
      return xhr.onreadystatechange = core.onReadyStateChange.bind({
        xhr: xhr,
        resolve: resolve,
        reject: reject
      });
    });
  };

  core.onReadyStateChange = function() {
    if (this.xhr.readyState === XMLHttpRequest.DONE) {
      if (this.xhr.status === 200 || this.xhr.status === 204) {
        return core.handleSuccess(this.xhr, this.resolve);
      } else {
        return core.handleFailure(this.xhr, this.reject);
      }
    }
  };

  core.handleSuccess = function(xhr, resolve) {
    var $dateDict, $jsonDict, data, key, ref, token, value;
    token = xhr.getResponseHeader('rubic-token');
    if (token) {
      localStorage.setItem('rubic-token', token);
    }
    ref = JSON.parse(xhr.responseText), $jsonDict = ref.$jsonDict, $dateDict = ref.$dateDict;
    data = {};
    for (key in $jsonDict) {
      value = $jsonDict[key];
      core.set(data, key, value);
    }
    for (key in $dateDict) {
      value = $dateDict[key];
      value = new Date(value);
      core.set(data, key, value);
    }
    return resolve(data);
  };

  core.handleFailure = function(xhr, reject) {
    var error;
    if (xhr.getResponseHeader('rubic-token-invalid')) {
      localStorage.removeItem('rubic-token');
    }
    error = JSON.parse(xhr.responseText);
    if ($onFailure) {
      return $onFailure(error);
    } else {
      return reject(error);
    }
  };

  core.set = function(data, key, value) {
    var i, j, last, len, name, names, next;
    names = key.split('.');
    last = names.pop();
    for (i = j = 0, len = names.length; j < len; i = ++j) {
      name = names[i];
      if (data[name] === void 0) {
        next = names[i + 1];
        if (/^\d+$/.test(next)) {
          data[name] = [];
        } else {
          data[name] = {};
        }
      }
      data = data[name];
    }
    return data[last] = value;
  };

  if (typeof (module !== void 0)) {
    global.rubic = core;
  } else {
    window.rubic = core;
  }

}).call(this);
